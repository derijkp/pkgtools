<manpage package="pkgtools" title="pkgtools" id="pkgtools" cat="cmd">
<namesection>
<name>pkgtools</name>
<desc>package initialization and building tools</desc>
</namesection>

<section>
<title>DESCRIPTION</title>
<p>
pkgtools is a small Tcl extension that bundles some commands that are
useful when working with packages, mostly from a developers point of view.
Several Tcl extensions/packages use and require pkgtools. If you just want
to use one of these extensions, you only need to put a pkgtools "binary"
somewhere Tcl can find it, and not care about the rest of this page.

</p>
</section>

<section>
<title>PACKAGE INIT COMMANDS</title>
<p>
A number of commands in pkgtools is used in the initializing of an extension
</p>
<commandlist>
<commanddef>
<command><cmd>pkgtools::init</cmd> <m>dir</m> <m>name</m> <m>?testcmd?</m> <m>?noc_file?</m> <m>?packagename?</m></command>
<desc>
This command will intialise an extension. It starts by searching the
appropriate architecture specific compiled code for the current
architecture in a number of possible directories starting from <m>dir</m>:
e.g. an architecture subdirectory of <m>dir</m>, <m>dir</m> itself, the
parent of <m>dir</m> (old convention). It uses <m>name</m> as a base of
the file to be found, adding the correct sharedlibextension, etc. It then
tries to dynamically load the library. If <m>testcmd</m> is given and not
empty, it is used to check whether the library is already loaded: this is
if the command <m>testcmd</m> already exists. If no compiled library could
be found, the file given by <m>noc_file</m> is sourced for a Tcl-only
fallback. A specific <m>packagename</m> can be given if needed to load the
library.
</desc>
</commanddef>

<commanddef>
<command><cmd>pkgtools::architecture</cmd></command>
<desc>
Returns the architecture Tcl on which is currently running in the form platform-machine
</desc>
</commanddef>

<commanddef>
<command><cmd>pkgtools::findlib</cmd> <m>dir</m> <m>name</m></command>
<desc>
find the appropriate architecture specific compiled code for the current
architecture in a number of possible directories starting from <m>dir</m>.
It uses <m>name</m> as a base of the file to be found, adding the correct
sharedlibextension, etc.
</desc>
</commanddef>

</commandlist>
</section>

<section>
<title>PACKAGE BUILD COMMANDS</title>
<p>
A number of commands in pkgtools is useful in building and installing a package
</p>
<commandlist>
<commanddef>
<command><cmd>pkgtools::install</cmd> <m>installdir</m></command>
<command><cmd>pkgtools::install</cmd> pkglibdir <m>pkglibdir</m> pkgtcllibdir <m>pkgtcllibdir</m> pkgdatadir <m>pkgdatadir</m> pkgincludedir <m>pkgincludedir</m> bindir <m>bindir</m> mandir <m>mandir</m></command>
<desc>
This command makes it easy to create an installation script by providing a number of variables and calling the command:
<example>
#!/bin/sh
# the next line restarts using tclsh \
exec tclsh "&#36;0" "&#36;@"

package require pkgtools
cd &#91;pkgtools::startdir&#93;

# settings
# --------

set libfiles {lib README pkgIndex.tcl init.tcl DESCRIPTION.txt}
set shareddatafiles README
set headers {}
set libbinaries &#91;::pkgtools::findlib &#91;file dir &#91;pkgtools::startdir&#93;&#93; Extral&#93;
set binaries {}

# standard
# --------
pkgtools::install &#36;argv
</example>
</desc>
</commanddef>
</commandlist>
</section>

<section>
<title>PACKAGE TEST COMMANDS</title>
<p>
A number of commands in pkgtools is useful in testing comands in a package
</p>
<commandlist>
<commanddef>
<command><cmd>pkgtools::test</cmd> <m>group</m> <m>description</m> <m>script</m> <m>expected</m> <m>args</m></command>
<desc>
Execute a test identified by <m>group</m> and <m>description</m>. The piece of code given in <m>script</m> is run. It should return <m>expected</m>. If the code contains an error or does not return the <m>expected</m> result, the error is displayed and the test flagged. If <m>args</m> contains "error", the script should cause an error, with <m>expected</m> as error message. If the <m>script</m> does not cause an error in this case, the test is flagged as failed. <m>script</m> is actually run within a proc, so if access to global variables is needed, they must be defined as such.
<example>
test pkgtools::test {basic} {
    set a 1
} {1}
</example>
<m>args</m> can also contain {skipon 1} or {skipon 0} that will skip or not skip the test respectively. The 1 or 0 is generated by code checking for e.g. the existance of a command, etc.:
<example>
test pkgtools::test {dict test} {
    dict set a a 1
} {a 1} [list skipon [catch {dict size {a 1}}]]
</example>
</desc>
</commanddef>

<commanddef>
<command><cmd>pkgtools::testsummarize</cmd></command>
<desc>Summarizes the results of all tests done. This command is usually put at the end of the testfile. It prints out all failed tests, or  "All tests ok" if everything went well. It also shows the number of tests skipped.
</desc>
</commanddef>

<commanddef>
<command><cmd>pkgtools::teststart</cmd></command>
<command><cmd>pkgtools::testfile</cmd> <m>file</m></command>
<desc>You usually make several test files, testing specific features. You sometimes want to run all of them. You can easily do this by making a file like this:
<example>
package require pkgtools
namespace import pkgtools::*
teststart
testfile test1.tcl
testfile test2.tcl
testsummarize
</example>
</desc>
</commanddef>

</commandlist>
</section>

<keywords>
<keyword>pkgtools</keyword>
<keyword>package</keyword>
<keyword>extension</keyword>
</keywords>

</manpage>
